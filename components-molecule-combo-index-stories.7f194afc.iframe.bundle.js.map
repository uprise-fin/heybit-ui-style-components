{"version":3,"file":"components-molecule-combo-index-stories.7f194afc.iframe.bundle.js","mappings":";;;;;;AA8GA;AACA;AACA;AACA;;;;;AAKA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;;;;AAIA;;;;;AAOA;AACA;;AAEA;;;;AAMA","sources":["webpack://heybit-ui-styled-components/./src/components/molecule/combo/index.ts","webpack://heybit-ui-styled-components/./src/components/atom/list/index.ts"],"sourcesContent":["import '@/components/atom/list';\nimport '@/components/atom/transition';\nimport { HbList } from '@/components/atom/list';\nimport { HbListOption } from '@/components/atom/list/type';\nimport { Base } from '@/components/base';\nimport { HbInput } from '@/components/molecule/input';\nimport { getElement } from '@/utils';\nimport { html } from 'lit';\nimport { customElement } from 'lit/decorators.js';\n\n/**\n * @fires event 값이 변경될때 발생\n * @property attributeSync true 시 value값이 arrtibute 싱크됨\n * @property fixed true 시 overflow에서 넘어감\n * @property value 기본 값\n * @property options Options[] 옵션\n * @property search 서치 온오프\n * @slot icon - optional, icon부분을 커스텀할때 사용\n * @slot caret - optional, caret부분을 커스텀할때 사용\n * @slot option - required, select의 옵션 엘리먼트\n * @csspart label\n * @csspart list\n */\n\n@customElement('hb-combo')\nexport class HbCombo extends Base {\n  static get styles() {\n    return [require('./style.scss').default];\n  }\n\n  inputEl?: HTMLInputElement;\n\n  parentQuery?: string;\n\n  parentEl?: HTMLElement;\n\n  attributeSync = false;\n\n  fixed = false;\n\n  search = false;\n\n  open = false;\n\n  top: number;\n\n  left: number;\n\n  width: number;\n\n  maxHeight: number;\n\n  value = '';\n\n  options: HbListOption[] = [];\n\n  placeholder = '검색어를 입력해주세요.';\n\n  emptyText = '검색결과가 없습니다.';\n\n  hasFocus = false;\n\n  inputValue = '';\n\n  resolve: (value?: unknown) => void = () => {};\n\n  static get properties() {\n    return {\n      open: { type: Boolean, Reflect: true },\n      search: { type: Boolean, Reflect: true },\n      attributeSync: { type: Boolean, Reflect: true },\n      fixed: { type: Boolean, Reflect: true },\n      top: { type: Number, Reflect: true },\n      left: { type: Number, Reflect: true },\n      width: { type: Number, Reflect: true },\n      maxHeight: { type: Number, Reflect: true },\n      value: { type: String, Reflect: true },\n      options: { type: Array, Reflect: true },\n      emptyText: { type: String, Reflect: true },\n      inputValue: { type: String, Reflect: true },\n      parentQuery: { type: String, Reflect: true },\n      hasFocus: { type: Boolean, Reflect: true }\n    };\n  }\n\n  get list() {\n    return this.options?.filter((x) => x.label.includes(this.inputValue)) || [];\n  }\n\n  get values() {\n    return this.options?.map((x) => x.value) || [];\n  }\n\n  get label() {\n    if (this.hasFocus || !this.options) return this.inputValue;\n    return this.options?.find((x) => x.value === this.value)?.label || '';\n  }\n\n  get scrollEventListener() {\n    if (this.parentQuery) return this.parentEl;\n    return window;\n  }\n\n  render() {\n    return html`\n      <hb-input\n        class=\"hb-combo__label\"\n        id=\"label\"\n        part=\"label\"\n        class=\"hb-combo__input\"\n        ?readonly=${!this.search}\n        value=${this.label}\n        placeholder=${this.placeholder}\n        @event=${this.onInput}\n      >\n        <slot name=\"icon\" class=\"hb-combo__label--icon\"></slot>\n        <hb-icon slot=\"slot--right\" icon=\"system/outline/arrow-dropdown\" size=\"small\"></hb-icon>\n      </hb-input>\n      <hb-transition id=\"select-transition\" ?show=${this.open} type=\"fade\">\n        <hb-list\n          tabindex=\"0\"\n          emptyText=${this.emptyText}\n          id=\"list\"\n          class=\"hb-combo__list${this.open ? ' hb-combo__list--open' : ''}\"\n          style=\"width: ${this.width}px;transform: translate(${this.left}px,${this.top}px);\"\n          @event=${this.onSelect}\n          .options=${this.list}\n          .value=${this.value}\n        ></hb-list>\n      </hb-transition>\n    `;\n  }\n\n  async connectedCallback() {\n    await super.connectedCallback();\n    this.onfocus = () => this.adapterShow();\n    this.onblur = () => this.onHide();\n    this.inputEl = await getElement<HTMLInputElement>(this.shadowRoot, 'label');\n    if (this.parentQuery) this.parentEl = document.querySelector(this.parentQuery);\n  }\n\n  disconnectedCallback() {\n    this.onfocus = () => null;\n    this.onblur = () => null;\n  }\n\n  onScroll() {\n    const { bottom } = this.getBoundingClientRect();\n    if (bottom > 100) this.maxHeight = window.innerHeight - bottom - 50;\n    this.top = -(this.parentEl ? this.parentEl?.scrollTop : window.scrollY);\n    this.left = -(this.parentEl ? this.parentEl?.scrollLeft : window.scrollX);\n  }\n\n  onScrollBound = this.onScroll.bind(this);\n\n  onInput(ev: InputEvent) {\n    const { target } = ev;\n    if (!(target instanceof HbInput)) return;\n    this.inputValue = target.value;\n  }\n\n  onSelect(ev: Event) {\n    ev.stopImmediatePropagation();\n    const { target } = ev;\n    if (!(target instanceof HbList)) return;\n    const { value } = target;\n    if (this.attributeSync) this.setAttribute('value', value!);\n    this.value = value!;\n    // this.dispatchEvent(new CustomEvent('event', evt));\n    this.onEvent(new CustomEvent('event'));\n    this.resolve();\n  }\n\n  onShow() {\n    const { width } = this.getBoundingClientRect();\n    this.open = true;\n    this.width = width;\n    if (this.search) {\n      this.hasFocus = true;\n      this.inputValue = '';\n    }\n    if (this.fixed) {\n      this.onScroll();\n      this.scrollEventListener.addEventListener('scroll', this.onScrollBound);\n    }\n  }\n\n  async adapterShow() {\n    this.onShow();\n    await new Promise((resolve) => (this.resolve = resolve));\n    this.onHide();\n  }\n\n  onHide() {\n    this.blur();\n    this.open = false;\n    if (this.search) this.hasFocus = false;\n    if (this.fixed) this.scrollEventListener.removeEventListener('scroll', this.onScrollBound);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'hb-combo': HbCombo;\n  }\n}\n","import { Base } from '@/components/base';\nimport { html } from 'lit';\nimport { customElement } from 'lit/decorators.js';\nimport { HbListEvent, HbListOption } from './type';\n\n/**\n * @fires event\n * @property src\n * @property multiSource\n * @property breakPoint\n * @property pcPrefix\n * @csspart picture\n * @csspart skeleton\n * @csspart img\n */\n\n@customElement('hb-list')\nexport class HbList extends Base {\n  static get styles() {\n    return [require('./style.scss').default];\n  }\n\n  options: HbListOption[] = [];\n\n  attributeSync = false;\n\n  open = false;\n\n  value = '';\n\n  emptyText = '';\n\n  width = 0;\n\n  maxHeight = 0;\n\n  static get properties() {\n    return {\n      options: { type: Array, Reflect: true },\n      value: { type: String, Reflect: true },\n      emptyText: { type: String, Reflect: true },\n      width: { type: Number, Reflect: true },\n      maxHeight: { type: Number, Reflect: true },\n      attributeSync: { type: Boolean, Reflect: true },\n      open: { type: Boolean, Reflect: true }\n    };\n  }\n\n  get values() {\n    return this.options.map((x) => x.value) || [];\n  }\n\n  sto = setTimeout(() => {}, 0);\n\n  onSelect(ev: HbListEvent) {\n    this.adapterHide();\n    if (!(ev.target instanceof HTMLButtonElement)) return;\n    const { target } = ev;\n    const { value } = target.dataset;\n    if (this.value === value || !this.values.includes(value)) return;\n    if (this.attributeSync) this.setAttribute('value', value!);\n    this.value = value!;\n    this.onEvent(new CustomEvent('event'));\n    // this.dispatchEvent(new CustomEvent('event', ev));\n  }\n\n  onHide() {\n    this.blur();\n    this.open = false;\n  }\n\n  adapterHide() {\n    this.sto = setTimeout(() => this.onHide(), 0);\n  }\n\n  render() {\n    return html`\n      <div\n        class=\"hb-list__wrap${this.options?.length ? '' : ' hb-list__wrap--empty'}\"\n        @click=${this.onSelect}\n        @keyup=${(evt: KeyboardEvent) => evt.key === 'Enter' && this.onSelect.call(this)}\n        data-empty-text=${this.emptyText}\n        part=\"list\"\n        id=\"list\"\n      >\n        ${this.options?.map(\n          (x) =>\n            html`\n              <button\n                tabindex=\"0\"\n                type=\"button\"\n                class=\"hb-list__btn\"\n                ?data-selected=${x.value === this.value}\n                data-value=${x.value}\n              >\n                ${x.label}\n              </button>\n            `\n        )}\n      </div>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'hb-list': HbList;\n  }\n}\n// const NAME = \"hb-list\";\n// customElements.get(NAME) ||\n//   customElements.define(\n//     NAME,\n//     class extends CustomElement {\n//       template = require(`./${NAME}.hbs`);\n//       css = require(`./${NAME}.scss`).default;\n//       properties = {\n//         id: {\n//           closeBtn: \"close-btn\",\n//           wrap: \"wrap\",\n//         },\n//       };\n//       constructor() {\n//         super();\n//       }\n//       connectedCallback(): void {\n//         super.connectedCallback();\n//         this.isWrapEl.onanimationstart = () => this.onAnimationStart();\n//         this.isWrapEl.onanimationend = () => this.onAnimationEnd();\n//         this.isCloseBtnEl.onclick = () => this.onHide();\n//       }\n//       get isCloseBtnEl() {\n//         return this.shadowRoot.getElementById(\n//           this.isProperties.id.closeBtn\n//         ) as HTMLButtonElement;\n//       }\n//       get isWrapEl() {\n//         return this.shadowRoot.getElementById(\n//           this.isProperties.id.wrap\n//         ) as HTMLButtonElement;\n//       }\n\n//       onHide() {\n//         this.classList.add(this.isProperties.classList.animation);\n//         super.onHide();\n//       }\n//     }\n//   );\n"],"names":[],"sourceRoot":""}