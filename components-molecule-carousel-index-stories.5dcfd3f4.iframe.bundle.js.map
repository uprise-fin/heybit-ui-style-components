{"version":3,"file":"components-molecule-carousel-index-stories.5dcfd3f4.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;;;;AAOA;;ACsVA;AAEA;;AAGA;;;AAGA;AACA;;AAEA;;AAEA;AAEA;AAKA;AAKA;AACA;AACA;AAGA;;AAIA;;;AAOA;;AAEA;AAEA;;;AAOA;;AAEA;AAEA;ACnZA;AACA;AACA;AAGA","sources":["webpack://heybit-ui-styled-components/./src/components/atom/loading/index.ts","webpack://heybit-ui-styled-components/./src/components/molecule/carousel/index.ts","webpack://heybit-ui-styled-components/./src/components/molecule/skeleton/index.ts"],"sourcesContent":["import { Base } from '@/components/base';\nimport { html } from 'lit';\nimport { customElement } from 'lit/decorators.js';\n\n@customElement('hb-loading')\nexport class HbLoading extends Base {\n  static get styles() {\n    return [require('./style.scss').default];\n  }\n\n  loaded = false;\n\n  delete = false;\n\n  duration: number;\n\n  background: string;\n\n  backgroundAccent: string;\n\n  static get properties() {\n    return {\n      loaded: { type: Boolean, Reflect: true },\n      duration: { type: Number, Reflect: true },\n      background: { type: String, Reflect: true },\n      backgroundAccent: { type: String, Reflect: true },\n      width: { type: String, Reflect: true },\n      height: { type: String, Reflect: true }\n    };\n  }\n\n  async connectedCallback() {\n    await super.connectedCallback();\n    this.ontransitionend = () => (this.delete ? this.remove() : this.setAttribute('done', ''));\n  }\n\n  // render() {\n  //   return Array(this.length).fill(null).map((_,i) => html`\n  //     <div class=\"hb-loading__wall\" part=${`cell-${i+1}`}></div>\n  //   `)\n\n  // }\n\n  render() {\n    return html`\n      <div\n        style=${`--duration:${this.duration || 2000}ms;--background:${\n          this.background || 'var(--husc__black--200)'\n        }; --background--accent:${this.backgroundAccent || 'var(--husc__white--50)'}`}\n        class=\"hb-loading__wall\"\n        part=\"wall\"\n      ></div>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'hb-loading': HbLoading;\n  }\n}\n","import '@/components/molecule/skeleton';\nimport { Base } from '@/components/base';\nimport { getChildren } from '@/utils';\nimport { html } from 'lit';\nimport { customElement, property, state } from 'lit/decorators.js';\nimport { HbCarouselEventStatus } from './type';\n\n/**\n * @property open 온 오프\n * @property width\n * @property persistent\n * @property hideCloseBtn\n * @property icon\n * @property title\n * @property auto Boolean, 자동롤링\n * @property pause Boolean, 마우스오버시 멈춤\n * @property infinite Boolean, 무한롤링 (마지막 오른쪽 아이템에서 첫 번째로 넘어가지 않고, 오른쪽으로 계속 진행)\n * @property indicate Boolean, 인디케이터\n * @property duration Number, 자동롤링 시간\n * @property speed Number, 롤링 속도\n * @property hasVariableChildren 메인 배너용, 영역 생성 후에 preload된 자식을 할당하는 등 자식이 가변적인 경우\n * @slot content - optional, 내용\n * @slot button - optional, 버튼\n * @slot anchor - optional, 앵커\n * @csspart container\n * @csspart icon\n * @csspart title\n * @csspart content\n * @csspart buttons\n * @csspart anchor\n */\n\n@customElement('hb-carousel')\nexport class HbCarousel extends Base {\n  static get styles() {\n    return [require('./style.scss').default];\n  }\n\n  /**\n   * @property {boolean} hasVariableChildren 메인 배너용, 영역 생성 후에 preload된 자식을 할당하는 등 자식이 가변적인 경우\n   */\n  @property({ type: Boolean })\n  hasVariableChildren: boolean = false;\n\n  //옵션\n  auto = false;\n\n  pause = false;\n\n  infinite = false;\n\n  rolling = false;\n\n  indicate = false;\n\n  draggable = false;\n\n  clickable = false;\n\n  moveable = false;\n\n  duration = 3000;\n\n  speed = 300;\n\n  flexWidth = 0;\n\n  fakeLength = 1;\n\n  index: number; // 현재 인덱스\n\n  visibleLength: number;\n\n  holderFlag = false;\n\n  _userIndex: number; // 인피니트등에 쓰이기 위해 내부에서 실제로 사용하는 인덱스\n\n  itemLength: number;\n\n  itemElements: HTMLElement[];\n\n  startPointer = {\n    clientX: 0,\n    clientY: 0\n  };\n\n  dragDistance = 0;\n\n  eventStatus: HbCarouselEventStatus = 'done';\n\n  sto: ReturnType<typeof setTimeout>;\n\n  // get open() {\n  //   return this._open;\n  // }\n  // set open(val: boolean) {\n  //   if (this._open !== val) {\n  //     this._open = val\n  //     this.onToggle(val)\n  //   }\n  // }\n\n  // @property()\n  // value!: string;\n  static get properties() {\n    return {\n      auto: { type: Boolean, Reflect: true },\n      pause: { type: Boolean, Reflect: true },\n      infinite: { type: Boolean, Reflect: true },\n      indicate: { type: Boolean, Reflect: true },\n      rolling: { type: Boolean, Reflect: true },\n      holderFlag: { type: Boolean, Reflect: true },\n      draggable: { type: Boolean, Reflect: true },\n      eventStatus: { type: String, Reflect: true },\n      dragDistance: { type: Number, Reflect: true },\n      index: { type: Number, Reflect: true },\n      flexWidth: { type: Number, Reflect: true },\n      fakeLength: { type: Number, Reflect: true },\n      itemLength: { type: Number, Reflect: true },\n      transitionFlag: { type: Boolean, Reflect: true },\n      visibleLength: { type: Number, Reflect: true },\n      duration: { type: Number, Reflect: true },\n      speed: { type: Number, Reflect: true }\n    };\n  }\n\n  get totalWidth() {\n    return (this.itemLength / this.visibleLength) * 100;\n  }\n\n  get transitionFlag() {\n    if (this.eventStatus === 'done') return true;\n    return false;\n  }\n\n  get positions() {\n    const arrayLength = this.itemLength * (this.infinite ? 1 + 1 + this.fakeLength : 1);\n    const index = this.infinite ? -this.itemLength : 0;\n    return Array(arrayLength)\n      .fill(null)\n      .map((_, i) => i + index)\n      .map((x) => (x * this.clientWidth) / this.visibleLength);\n  }\n\n  set userIndex(index: number) {\n    if (this.infinite) index -= this.itemLength;\n    this._userIndex = index;\n  }\n\n  get userIndex() {\n    return this._userIndex;\n  }\n\n  get transitionDuration() {\n    if (this.holderFlag) return 1000000000;\n    if (this.transitionFlag) return this.rolling ? this.duration : this.speed;\n    return 0;\n  }\n\n  get itemPosition() {\n    if (this.holderFlag) return '';\n    const currentPosition = (this.index * this.clientWidth) / this.visibleLength;\n    if (['doing', 'fake'].includes(this.eventStatus)) {\n      this.userIndex = this.closeIndex(currentPosition + this.dragDistance * 2);\n      return `${-currentPosition - this.dragDistance}px`;\n    }\n\n    return `${(this.index / this.visibleLength) * -100}%`;\n  }\n\n  get shouldLazyUpdate() {\n    return this.hasVariableChildren;\n  }\n\n  onResizeBound = this.onResize.bind(this);\n\n  onEventStartBound = this.onEventStart.bind(this);\n\n  onEventEndBound = this.onEventEnd.bind(this);\n\n  onEventDoingBound = this.onEventDoing.bind(this);\n\n  @state()\n  private clonedItemsBefore: HTMLElement[] = [];\n\n  @state()\n  private clonedItemsAfter: HTMLElement[] = [];\n\n  async connectedCallback() {\n    super.connectedCallback();\n\n    this.itemElements = await getChildren(this.children);\n    this.itemLength = this.itemElements.length;\n\n    if (!this.shouldLazyUpdate && this.infinite) {\n      const cloneAppend = (element: HTMLElement, slot: string) => {\n        const cloneBefore = element.cloneNode(true) as HTMLElement;\n        cloneBefore.setAttribute('slot', `fake-${slot}`);\n        this.appendChild(cloneBefore);\n      };\n      this.itemElements.forEach((element) => {\n        cloneAppend(element, 'before');\n        let i = 0;\n        while (i++ < this.fakeLength) {\n          cloneAppend(element, 'after');\n        }\n      });\n    }\n\n    if (this.draggable) {\n      this.addEventListener('mousedown', this.onEventStartBound);\n      window.addEventListener('mouseup', this.onEventEndBound);\n      window.addEventListener('mousemove', this.onEventDoingBound);\n      this.addEventListener('touchstart', this.onEventStartBound);\n      window.addEventListener('touchend', this.onEventEndBound);\n      window.addEventListener('touchmove', this.onEventDoingBound);\n    }\n    if (this.auto && this.itemLength > 1) {\n      const step = this.rolling ? 1 : undefined;\n      this.onAuto(step);\n      if (this.pause) {\n        this.onmouseenter = () => {\n          if (this.eventStatus === 'done') {\n            this.holderFlag = true;\n            clearTimeout(this.sto);\n          }\n        };\n        this.onmouseleave = () => {\n          if (this.eventStatus === 'done') {\n            this.holderFlag = false;\n            this.onAuto();\n          }\n        };\n        this.ontouchstart = () => {\n          if (this.eventStatus === 'done') {\n            this.holderFlag = true;\n            clearTimeout(this.sto);\n          }\n        };\n        this.ontouchend = () => {\n          if (this.eventStatus === 'done') {\n            this.holderFlag = false;\n            this.onAuto();\n          }\n        };\n      }\n    }\n    if (this.flexWidth) {\n      this.onResize();\n      window.addEventListener('resize', this.onResizeBound);\n    }\n  }\n\n  async firstUpdated() {\n    if (!this.shouldLazyUpdate) {\n      return;\n    }\n\n    if (!this.infinite) {\n      return;\n    }\n\n    this.itemElements = await getChildren(this.children);\n    this.itemLength = this.itemElements.length;\n\n    this.itemElements.forEach((element) => {\n      const cloneBefore = element.cloneNode(true) as HTMLElement;\n      this.clonedItemsBefore.push(cloneBefore);\n\n      for (let i = 0; i < this.fakeLength; i++) {\n        const cloneAfter = element.cloneNode(true) as HTMLElement;\n        this.clonedItemsAfter.push(cloneAfter);\n      }\n    });\n  }\n\n  disconnectedCallback() {\n    if (this.draggable && this.itemLength > 1) {\n      this.removeEventListener('mousedown', this.onEventStartBound);\n      window.removeEventListener('mouseup', this.onEventEndBound);\n      window.removeEventListener('mousemove', this.onEventDoingBound);\n      this.removeEventListener('touchstart', this.onEventStartBound);\n      window.removeEventListener('touchend', this.onEventEndBound);\n      window.removeEventListener('touchmove', this.onEventDoingBound);\n    }\n    if (this.flexWidth) window.removeEventListener('resize', this.onResizeBound);\n  }\n\n  onResize() {\n    this.visibleLength = this.clientWidth / this.flexWidth;\n  }\n\n  async onAuto(step: number = 0): Promise<void> {\n    if (!this.auto) return;\n    let duration = this.duration;\n    clearTimeout(this.sto);\n    if (this.index + step < this.itemLength) {\n      if (this.eventStatus !== 'done') this.eventStatus = 'done';\n      this.index += step;\n      step = 1;\n    } else {\n      this.index = 0;\n      duration = 0;\n      step = 0;\n      if (this.infinite) {\n        this.eventStatus = 'fake';\n        this.dragDistance = -this.clientWidth / this.visibleLength;\n        this.userIndex = this.itemLength - 1;\n      }\n    }\n\n    this.sto = setTimeout(() => this.onAuto(step), duration);\n  }\n\n  onIndicateClick(index: number) {\n    this.onAuto(index);\n    this.index = index;\n  }\n\n  onItemClick(event: MouseEvent) {\n    if (!this.clickable) return;\n    if (!this.moveable) return;\n    const { target } = event;\n    if (target instanceof HTMLElement)\n      this.index = this.itemElements.findIndex((x: ChildNode) => target.isEqualNode(x));\n  }\n\n  getClientPoint(event: MouseEvent | TouchEvent) {\n    let clientX = 0;\n    let clientY = 0;\n    if (event instanceof MouseEvent) {\n      clientX = event.clientX;\n      clientY = event.clientY;\n    } else {\n      clientX = event.touches[0].clientX;\n      clientY = event.touches[0].clientY;\n    }\n    return { clientX, clientY };\n  }\n\n  onEventStart(event: MouseEvent | TouchEvent) {\n    if (this.eventStatus === 'done') {\n      this.holderFlag = false;\n      this.eventStatus = 'start';\n      clearTimeout(this.sto);\n      const { clientX, clientY } = this.getClientPoint(event);\n\n      this.startPointer = {\n        clientX,\n        clientY\n      };\n    }\n  }\n\n  onEventEnd() {\n    if (this.eventStatus === 'doing') {\n      this.index = this.userIndex;\n      this.dragDistance = 0;\n    }\n    this.eventStatus = 'done';\n    this.onAuto();\n  }\n\n  closeIndex(position: number) {\n    const { length } = this.itemElements;\n    const diff = this.positions.map((x) => this.diff(x, position));\n    const closePosition = Math.min(...diff);\n    let index = diff.findIndex((x) => closePosition === x);\n    const margin = this.infinite ? length : 0;\n    const max = margin + length - 1; // 안전장치. 기본 인덱스 이상으로 안보이기\n    const min = margin; // 기본 인덱스 이하로 안보이기\n    if (index > max) index = max;\n    else if (index < min) index = min;\n    return index;\n  }\n\n  diff(a: number, b: number) {\n    return a > b ? a - b : b - a;\n  }\n\n  onEventDoing(event: MouseEvent | TouchEvent) {\n    if (['start', 'doing'].includes(this.eventStatus)) {\n      const { clientX, clientY } = this.getClientPoint(event);\n      const starterClientX = this.startPointer.clientX;\n      const starterClientY = this.startPointer.clientY;\n      this.dragDistance = starterClientX - clientX;\n      if (this.eventStatus === 'start')\n        if (this.diff(starterClientX, clientX) > 10 || this.diff(starterClientY, clientY) > 10)\n          this.eventStatus = 'doing'; // 드레그가 시작됐다고 판단하는 움직임 +- 10\n    }\n  }\n\n  render() {\n    return html`\n      <div\n        class=${'hb-carousel__wrap' +\n        (this.eventStatus === 'doing' ? ' hb-carousel__wrap--drag' : '')}\n        style=\"transform: translateX(${this.itemPosition});--duration: ${this\n          .transitionDuration}ms;--type: ${this.rolling ? 'linear' : 'ease'};\"\n      >\n        ${this.infiniteSlotBeforeTemplate}\n        <slot\n          class=\"hb-carousel__items\"\n          @click=\"${this.onItemClick}\"\n          style=\"width: ${this.totalWidth}%;\"\n        ></slot>\n        ${this.infiniteSlotAfterTemplate}\n      </div>\n      ${this.indicateTemplate}\n    `;\n  }\n\n  get indicateTemplate() {\n    if (this.indicate && this.itemLength > 1)\n      return html`<div class=\"hb-carousel__indicate\" part=\"indicate\">\n        ${Array(this.itemLength)\n          .fill(null)\n          .map(\n            (_, i) =>\n              html`<button\n                @click=${() => this.onIndicateClick(i)}\n                part=\"indicate-btn${i === this.index ? ' accent' : ''}\"\n                class=\"hb-carousel__indicate__btn${i === this.index\n                  ? ' hb-carousel__indicate__btn--accent'\n                  : ''}\"\n                title=\"View Item ${i + 1}\"\n              ></button>`\n          )}\n      </div>`;\n  }\n\n  get infiniteSlotBeforeTemplate() {\n    if (this.infinite)\n      return html`<slot\n        class=\"hb-carousel__items hb-carousel__items--fake-before\"\n        name=\"fake-before\"\n        style=\"width: ${this.totalWidth}%; margin-left: ${-this.totalWidth}%;\"\n      >\n        ${this.clonedItemsBefore.map((item) => html`${item}`)}\n      </slot>`;\n  }\n\n  get infiniteSlotAfterTemplate() {\n    if (this.infinite)\n      return html`<slot\n        class=\"hb-carousel__items hb-carousel__items--fake-after\"\n        name=\"fake-after\"\n        style=\"width: ${this.totalWidth * this.fakeLength}%;\"\n      >\n        ${this.clonedItemsAfter.map((item) => html`${item}`)}\n      </slot>`;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'hb-carousel': HbCarousel;\n  }\n}\n","import '@/components/atom/loading';\nimport { html } from 'lit';\nimport { customElement } from 'lit/decorators.js';\nimport { Base } from '@/components/base';\nimport { HbSkeletonType } from './type';\n\n@customElement('hb-skeleton')\nexport class HbSkeleton extends Base {\n  static get styles() {\n    return [require('./style.scss').default];\n  }\n\n  type: HbSkeletonType;\n\n  duration: number;\n\n  background: string;\n\n  backgroundAccent: string;\n\n  static get properties() {\n    return {\n      duration: { type: Number, Reflect: true },\n      background: { type: String, Reflect: true },\n      backgroundAccent: { type: String, Reflect: true },\n      type: { type: String, Reflect: true }\n    };\n  }\n\n  get skeletonLength() {\n    if (['card', 'drop-menu-top'].includes(this.type)) return 3;\n    if (['drop-menu-bottom'].includes(this.type)) return 2;\n    return 1;\n  }\n\n  // render() {\n  //   return Array(this.length).fill(null).map((_,i) => html`\n  //     <div class=\"hb-skeleton__wall\" part=${`cell-${i+1}`}></div>\n  //   `)\n\n  // }\n\n  render() {\n    return Array(this.skeletonLength)\n      .fill(null)\n      .map(\n        () =>\n          html`<hb-loading\n            duration=${this.duration}\n            background=${this.background}\n            backgroundAccent=${this.backgroundAccent}\n          ></hb-loading> `\n      );\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'hb-skeleton': HbSkeleton;\n  }\n}\n"],"names":[],"sourceRoot":""}